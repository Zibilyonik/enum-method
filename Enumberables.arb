module Enumerable
    def my_each
        return unless block_given?
        for item in self do
            yield item
        end
    end

    def my_each_with_index
        for item in self do 
           yield(item, self.index(item))
        end
    end

    def my_select
        arr=[]
        for item in self do
            arr << item if yield(item)
        end
        arr
    end

    def my_all?
        return null if self.length <= 0
        return false if my_select{|item| yield(item)}.length != self.length
        return true
    end

    def my_any?
        return null if self.length <= 0
        return true if my_select{|item| yield(item)}.length != 0
        return false
    end
    
    def my_none?
        return null if self.length <= 0
        return true if my_select{|item| yield(item)}.length == 0
        return false
    end

    def my_count(number = nil)
        if number!= nil
            i = 0
            for item in self do
                if item == number
                    i += 1
                end
            end
            return i
        end
        return self.length unless block_given?
        return my_select{|item| yield(item)}.length
    end

    def my_inject(*args)
        if args[0].is_a?(Symbol)
            sym = args[0]
            args.delete_at(0)
        end
        args[0] ? memo = args[0] : memo = 0
        if sym
            self.my_each{ |item| memo = memo ? memo.send(sym, item) : item}
        elsif block_given?
            self.my_each{ |item| memo = yield(memo, item)}
        end
        memo
    end
        
end

Arr = [20, 50, 120, 600, 21]
Arr2 = ["a", "b", "c", "d", "e"]
Arr.my_each{|x| p x + 5}
Arr.my_each_with_index{|x, i| p "number: #{x+5}, index: #{i}"}
p Arr.my_select{|x| x.even?}
p Arr.my_all?{|x| x.even?}
p Arr.my_any?{|x| x < 1000}
p Arr.my_none?{|x| x < 20}
p Arr.my_count{|x| x % 3 == 2}
p Arr.my_inject(:+, 5)